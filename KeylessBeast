--[[
  Mod Menu Rayfield – WalkSpeed + ESP + Fly + Click TP + Noclip + Hitbox Expander + Combat (Street Life Remastered)
--]]

local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local Camera = workspace.CurrentCamera
local Mouse = LocalPlayer:GetMouse()
local ReplicatedStorage = game:GetService("ReplicatedStorage")

-- Ładowanie Rayfield z obsługą błędów
local success, Rayfield = pcall(function()
    return loadstring(game:HttpGet('https://sirius.menu/rayfield'))()
end)

if not success then
    warn("Failed to load Rayfield library: " .. tostring(Rayfield))
    return
end

local Window = Rayfield:CreateWindow({
    Name = "Bojuwkarz Menu",
    LoadingTitle = "Ładowanie GUI",
    LoadingSubtitle = "WalkSpeed + ESP + Fly + Click TP + Noclip + Hitbox Expander + Combat",
    ConfigurationSaving = {
        Enabled = true,
        FileName = "boj_menu"
    }
})

-- Tworzenie zakładek (Items usunięte)
local MainTab = Window:CreateTab("Main", 4483362458)
local EspTab = Window:CreateTab("ESP", 4483362458)
local PlayerTab = Window:CreateTab("Player", 4483362458)
local HitboxTab = Window:CreateTab("Hitbox Expander", 4483362458)
local CombatTab = Window:CreateTab("Combat", 4483362458)

---------------------------------------------------
-- Main Tab: Developer and Version Info
---------------------------------------------------
MainTab:CreateLabel("Developer: Swifty")
MainTab:CreateLabel("Version: 0.5 Beta")

--- NOWE Z SCX HUB: Debug button do remotes (przeniesione z Items do Main)
MainTab:CreateButton({
    Name = "Print Remotes (Debug)",
    Callback = function()
        for _, v in pairs(ReplicatedStorage:GetChildren()) do
            if v:IsA("RemoteEvent") then
                print("Remote: " .. v.Name)
            end
        end
    end
})

---------------------------------------------------
-- Player Tab: WalkSpeed, Fly, Click TP, Noclip + Infinite Stamina
---------------------------------------------------
local speedEnabled, setSpeed = false, 16
local flyEnabled, flySpeed = false, 100
local clickTpEnabled, clickTpKey = false, Enum.KeyCode.Q
local noclipEnabled = false
local infiniteStaminaEnabled = false
local staminaMax = 100
local playerConn = nil
local noclipConn = nil
local clickTpConn = nil
local clickTpConnections = nil
local isClickTpKeyHeld = false
local originalStaminaValues = {} --- POPRAWKA: Przechowuj oryginalne wartości stamina

-- Cache postaci dla optymalizacji
local function getCharacterComponents()
    local char = LocalPlayer.Character
    return char, char and char:FindFirstChild("HumanoidRootPart"), char and char:FindFirstChildOfClass("Humanoid")
end

-- Jedna pętla Heartbeat dla WalkSpeed, Fly, Infinite Ammo, Infinite Stamina
local infiniteAmmoEnabled = false
local function updatePlayerMechanics()
    playerConn = RunService.Heartbeat:Connect(function(dt)
        local char, root, hum = getCharacterComponents()
        if not (char and root and hum) then return end

        -- WalkSpeed
        if speedEnabled and hum.WalkSpeed ~= setSpeed then
            hum.WalkSpeed = setSpeed
        end

        -- Fly
        if flyEnabled then
            hum.PlatformStand = true
            local dir = Vector3.zero
            if UserInputService:IsKeyDown(Enum.KeyCode.W) then dir += Camera.CFrame.LookVector end
            if UserInputService:IsKeyDown(Enum.KeyCode.S) then dir -= Camera.CFrame.LookVector end
            if UserInputService:IsKeyDown(Enum.KeyCode.A) then dir -= Camera.CFrame.RightVector end
            if UserInputService:IsKeyDown(Enum.KeyCode.D) then dir += Camera.CFrame.RightVector end
            if UserInputService:IsKeyDown(Enum.KeyCode.Space) then dir += Vector3.new(0, 1, 0) end
            if UserInputService:IsKeyDown(Enum.KeyCode.LeftControl) then dir -= Vector3.new(0, 1, 0) end
            root.Velocity = dir.Magnitude > 0 and dir.Unit * flySpeed or Vector3.zero
        elseif hum.PlatformStand then
            hum.PlatformStand = false
            root.Velocity = Vector3.zero
        end

        -- Infinite Stamina
        if infiniteStaminaEnabled then
            -- Sprawdź standardowy Humanoid stamina
            if hum:FindFirstChild("Stamina") then
                if not originalStaminaValues[hum] then
                    originalStaminaValues[hum] = hum.Stamina.Value --- POPRAWKA: Zapisz oryginalną wartość
                end
                hum.Stamina.Value = staminaMax
            end
            -- Custom values w Character
            for _, val in pairs(char:GetDescendants()) do
                if val:IsA("IntValue") or val:IsA("NumberValue") then
                    if val.Name:lower():match("stamina") or val.Name:lower():match("energy") then
                        if not originalStaminaValues[val] then
                            originalStaminaValues[val] = val.Value --- POPRAWKA: Zapisz oryginalną wartość
                        end
                        val.Value = staminaMax
                    end
                end
            end
            -- Hook na skrypty stamina
            for _, obj in pairs(char:GetDescendants()) do
                if obj:IsA("LocalScript") and obj.Name:lower():match("stamina") then
                    for _, conn in pairs(getconnections(obj)) do
                        if conn.Function and type(conn.Function) == "function" then
                            conn:Disable()
                        end
                    end
                end
            end
        end

        -- Infinite Ammo
        if infiniteAmmoEnabled then
            for _, tool in pairs(LocalPlayer.Backpack:GetChildren()) do
                if tool:IsA("Tool") then
                    for _, value in pairs(tool:GetChildren()) do
                        if value:IsA("IntValue") or value:IsA("NumberValue") then
                            if value.Name:lower():match("ammo") or value.Name:lower():match("clip") or value.Name:lower():match("bullets") or value.Name:lower():match("magazine") or value.Name:lower():match("rounds") then
                                print("Found ammo value: " .. value.Name .. " in " .. tool.Name) -- Debugowanie
                                value.Value = 9999
                            end
                        end
                    end
                end
            end
            if char then
                for _, tool in pairs(char:GetChildren()) do
                    if tool:IsA("Tool") then
                        for _, value in pairs(tool:GetChildren()) do
                            if value:IsA("IntValue") or value:IsA("NumberValue") then
                                if value.Name:lower():match("ammo") or value.Name:lower():match("clip") or value.Name:lower():match("bullets") or value.Name:lower():match("magazine") or value.Name:lower():match("rounds") then
                                    print("Found ammo value: " .. value.Name .. " in " .. tool.Name) -- Debugowanie
                                    value.Value = 9999
                                end
                            end
                        end
                    end
                end
            end
        end
    end)
end

-- Funkcja do resetowania stamina --- POPRAWKA: Przywraca oryginalne wartości
local function resetStamina()
    local char, _, hum = getCharacterComponents()
    if not (char and hum) then return end

    if hum:FindFirstChild("Stamina") and originalStaminaValues[hum] then
        hum.Stamina.Value = originalStaminaValues[hum]
        originalStaminaValues[hum] = nil
    end
    for _, val in pairs(char:GetDescendants()) do
        if (val:IsA("IntValue") or val:IsA("NumberValue")) and (val.Name:lower():match("stamina") or val.Name:lower():match("energy")) then
            if originalStaminaValues[val] then
                val.Value = originalStaminaValues[val]
                originalStaminaValues[val] = nil
            end
        end
    end
    -- Re-enable connections stamina
    for _, obj in pairs(char:GetDescendants()) do
        if obj:IsA("LocalScript") and obj.Name:lower():match("stamina") then
            for _, conn in pairs(getconnections(obj)) do
                if conn.Function and type(conn.Function) == "function" then
                    conn:Enable()
                end
            end
        end
    end
end

-- WalkSpeed UI
PlayerTab:CreateSlider({
    Name = "Ustaw prędkość chodzenia",
    Range = {16, 200},
    Increment = 1,
    CurrentValue = setSpeed,
    Callback = function(v)
        setSpeed = v
    end
})

PlayerTab:CreateToggle({
    Name = "WalkSpeed ON/OFF",
    CurrentValue = false,
    Callback = function(state)
        speedEnabled = state
        if speedEnabled and not playerConn then
            updatePlayerMechanics()
        elseif not (speedEnabled or flyEnabled or infiniteAmmoEnabled or infiniteStaminaEnabled) and playerConn then
            playerConn:Disconnect()
            playerConn = nil
            local _, _, hum = getCharacterComponents()
            if hum then hum.WalkSpeed = 16 end
        end
    end
})

-- Fly UI
PlayerTab:CreateSlider({
    Name = "Fly speed",
    Range = {10, 300},
    Increment = 5,
    CurrentValue = flySpeed,
    Callback = function(v)
        flySpeed = v
    end
})

PlayerTab:CreateToggle({
    Name = "Fly ON/OFF",
    CurrentValue = false,
    Callback = function(state)
        flyEnabled = state
        if flyEnabled and not playerConn then
            updatePlayerMechanics()
        elseif not (speedEnabled or flyEnabled or infiniteAmmoEnabled or infiniteStaminaEnabled) and playerConn then
            playerConn:Disconnect()
            playerConn = nil
            local _, _, hum = getCharacterComponents()
            if hum then hum.PlatformStand = false end
        end
    end
})

-- Infinite Stamina UI
PlayerTab:CreateSlider({
    Name = "Max Stamina",
    Range = {50, 500},
    Increment = 10,
    CurrentValue = staminaMax,
    Callback = function(v)
        staminaMax = v
    end
})

PlayerTab:CreateToggle({
    Name = "Infinite Stamina ON/OFF",
    CurrentValue = false,
    Callback = function(state)
        infiniteStaminaEnabled = state
        if infiniteStaminaEnabled and not playerConn then
            updatePlayerMechanics()
        elseif not (speedEnabled or flyEnabled or infiniteAmmoEnabled or infiniteStaminaEnabled) and playerConn then
            playerConn:Disconnect()
            playerConn = nil
            resetStamina() --- POPRAWKA: Reset stamina przy OFF
        end
    end
})

-- Click TP UI
PlayerTab:CreateDropdown({
    Name = "Click TP Key",
    Options = {"Q", "E", "F", "T", "R", "Z"},
    CurrentOption = "Q",
    Callback = function(option)
        clickTpKey = Enum.KeyCode[option]
    end
})

PlayerTab:CreateToggle({
    Name = "Click TP ON/OFF",
    CurrentValue = false,
    Callback = function(state)
        clickTpEnabled = state
        if clickTpEnabled then
            local beganConn = UserInputService.InputBegan:Connect(function(input, gameProcessed)
                if not gameProcessed and input.KeyCode == clickTpKey then
                    isClickTpKeyHeld = true
                end
            end)
            local endedConn = UserInputService.InputEnded:Connect(function(input, gameProcessed)
                if input.KeyCode == clickTpKey then
                    isClickTpKeyHeld = false
                end
            end)
            clickTpConn = Mouse.Button1Down:Connect(function()
                if isClickTpKeyHeld and clickTpEnabled then
                    local _, root = getCharacterComponents()
                    if root then
                        root.CFrame = CFrame.new(Mouse.Hit.Position + Vector3.new(0, 3, 0))
                    end
                end
            end)
            clickTpConnections = {beganConn, endedConn, clickTpConn}
        else
            isClickTpKeyHeld = false
            if clickTpConnections then
                for _, conn in ipairs(clickTpConnections) do
                    conn:Disconnect()
                end
                clickTpConnections = nil
            end
            if clickTpConn then
                clickTpConn:Disconnect()
                clickTpConn = nil
            end
        end
    end
})

-- Noclip UI
PlayerTab:CreateToggle({
    Name = "Noclip ON/OFF",
    CurrentValue = false,
    Callback = function(state)
        noclipEnabled = state
        if noclipEnabled then
            noclipConn = RunService.Stepped:Connect(function()
                local char = LocalPlayer.Character
                if char then
                    for _, part in ipairs(char:GetDescendants()) do
                        if part:IsA("BasePart") then
                            part.CanCollide = false
                        end
                    end
                end
            end)
        else
            if noclipConn then
                noclipConn:Disconnect()
                noclipConn = nil
            end
            local char = LocalPlayer.Character
            if char then
                for _, part in ipairs(char:GetDescendants()) do
                    if part:IsA("BasePart") then
                        part.CanCollide = true
                    end
                end
            end
        end
    end
})

---------------------------------------------------
-- Hitbox Expander Tab
---------------------------------------------------
local hitboxEnabled = false
local headChamsEnabled = false
local hitboxSize = 2
local headChamsColor = Color3.fromRGB(255, 255, 0)
local originalHeadSizes = {}
local headChamsDrawings = {}
local hitboxRefreshConn = nil

local function updateHitbox(plr)
    if plr == LocalPlayer then return end
    local char = plr.Character
    local head = char and char:FindFirstChild("Head")
    if head and head:IsA("BasePart") then
        if hitboxEnabled then
            if not originalHeadSizes[plr] then
                originalHeadSizes[plr] = head.Size
            end
            head.Size = originalHeadSizes[plr] * hitboxSize
            head.CanCollide = false
        else
            if originalHeadSizes[plr] then
                head.Size = originalHeadSizes[plr]
                head.CanCollide = true
            end
        end
    end
end

local function updateHeadChams(plr)
    if plr == LocalPlayer then return end
    local char = plr.Character
    local head = char and char:FindFirstChild("Head")
    if head and head:IsA("BasePart") then
        local highlight = headChamsDrawings[plr]
        if not highlight then
            highlight = Instance.new("Highlight")
            highlight.FillColor = headChamsColor
            highlight.OutlineColor = Color3.fromRGB(255, 255, 255)
            highlight.FillTransparency = 0.5
            highlight.OutlineTransparency = 0
            highlight.Parent = head
            headChamsDrawings[plr] = highlight
        end
        highlight.Adornee = headChamsEnabled and head or nil
        highlight.FillColor = headChamsColor
        highlight.Enabled = headChamsEnabled and head ~= nil
    end
end

local function refreshHitboxes()
    hitboxRefreshConn = RunService.Heartbeat:Connect(function()
        if hitboxEnabled then
            for _, plr in ipairs(Players:GetPlayers()) do
                updateHitbox(plr)
            end
        end
    end)
end

Players.PlayerAdded:Connect(function(plr)
    updateHitbox(plr)
    updateHeadChams(plr)
end)

Players.PlayerRemoving:Connect(function(plr)
    originalHeadSizes[plr] = nil
    if headChamsDrawings[plr] then
        headChamsDrawings[plr]:Remove()
        headChamsDrawings[plr] = nil
    end
end)

for _, p in ipairs(Players:GetPlayers()) do
    updateHitbox(p)
    updateHeadChams(p)
end

-- Hitbox Expander UI
HitboxTab:CreateSlider({
    Name = "Head Hitbox Size",
    Range = {1, 10},
    Increment = 0.5,
    CurrentValue = hitboxSize,
    Callback = function(v)
        hitboxSize = v
        if hitboxEnabled then
            for _, plr in ipairs(Players:GetPlayers()) do
                updateHitbox(plr)
            end
        end
    end
})

HitboxTab:CreateToggle({
    Name = "Hitbox Expander ON/OFF",
    CurrentValue = false,
    Callback = function(state)
        hitboxEnabled = state
        for _, plr in ipairs(Players:GetPlayers()) do
            updateHitbox(plr)
        end
        if hitboxEnabled and not hitboxRefreshConn then
            refreshHitboxes()
        elseif not hitboxEnabled and hitboxRefreshConn then
            hitboxRefreshConn:Disconnect()
            hitboxRefreshConn = nil
        end
    end
})

HitboxTab:CreateToggle({
    Name = "Head Chams ON/OFF",
    CurrentValue = false,
    Callback = function(state)
        headChamsEnabled = state
        for _, plr in ipairs(Players:GetPlayers()) do
            updateHeadChams(plr)
        end
    end
})

HitboxTab:CreateColorPicker({
    Name = "Head Chams Color",
    Color = headChamsColor,
    Callback = function(color)
        headChamsColor = color
        for _, highlight in pairs(headChamsDrawings) do
            highlight.FillColor = headChamsColor
        end
    end
})

---------------------------------------------------
-- Combat Tab: Aimlock + Infinite Ammo
---------------------------------------------------
local aimlockEnabled = false
local aimlockKey = Enum.KeyCode.E
local aimlockDistance = 100
local aimlockFOV = 60
local showFOVCircle = false
local isAimlockActive = false
local aimlockConn = nil
local fovCircle = Drawing.new("Circle")

fovCircle.Visible = false
fovCircle.Radius = 0
fovCircle.Color = Color3.fromRGB(255, 255, 255)
fovCircle.Thickness = 2
fovCircle.Filled = false
fovCircle.Position = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)

local function getClosestPlayerHead()
    local closestPlayer = nil
    local closestDistance = aimlockDistance
    local camPos = Camera.CFrame.Position
    local char, root = getCharacterComponents()

    if not (char and root) then return nil end

    for _, plr in ipairs(Players:GetPlayers()) do
        if plr == LocalPlayer then continue end
        local pChar = plr.Character
        local pHead = pChar and pChar:FindFirstChild("Head")
        if pHead then
            local distance = (pHead.Position - camPos).Magnitude
            local vector = pHead.Position - camPos
            local angle = math.deg(math.acos(Camera.CFrame.LookVector:Dot(vector.Unit)))
            if distance <= closestDistance and angle <= aimlockFOV / 2 then
                closestDistance = distance
                closestPlayer = plr
            end
        end
    end
    return closestPlayer and closestPlayer.Character and closestPlayer.Character:FindFirstChild("Head")
end

-- Combat UI
CombatTab:CreateDropdown({
    Name = "Aimlock Key",
    Options = {"Q", "E", "F", "T", "R", "Z"},
    CurrentOption = "E",
    Callback = function(option)
        aimlockKey = Enum.KeyCode[option]
    end
})

CombatTab:CreateSlider({
    Name = "Aimlock Distance",
    Range = {0, 300},
    Increment = 5,
    CurrentValue = aimlockDistance,
    Callback = function(v)
        aimlockDistance = v
    end
})

CombatTab:CreateSlider({
    Name = "Aimlock FOV",
    Range = {10, 120},
    Increment = 5,
    CurrentValue = aimlockFOV,
    Callback = function(v)
        aimlockFOV = v
        if showFOVCircle then
            fovCircle.Radius = math.tan(math.rad(aimlockFOV / 2)) * (Camera.ViewportSize.Y / 2)
        end
    end
})

CombatTab:CreateToggle({
    Name = "Show FOV Circle ON/OFF",
    CurrentValue = false,
    Callback = function(state)
        showFOVCircle = state
        fovCircle.Visible = showFOVCircle
        if showFOVCircle then
            fovCircle.Radius = math.tan(math.rad(aimlockFOV / 2)) * (Camera.ViewportSize.Y / 2)
        end
    end
})

CombatTab:CreateToggle({
    Name = "Aimlock ON/OFF",
    CurrentValue = false,
    Callback = function(state)
        aimlockEnabled = state
        if aimlockEnabled then
            local beganConn = UserInputService.InputBegan:Connect(function(input, gameProcessed)
                if not gameProcessed and input.KeyCode == aimlockKey then
                    isAimlockActive = not isAimlockActive
                end
            end)
            aimlockConn = RunService.RenderStepped:Connect(function()
                if isAimlockActive and aimlockEnabled then
                    local targetHead = getClosestPlayerHead()
                    if targetHead then
                        Camera.CFrame = CFrame.new(Camera.CFrame.Position, targetHead.Position)
                    end
                end
                if showFOVCircle then
                    fovCircle.Position = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
                    fovCircle.Radius = math.tan(math.rad(aimlockFOV / 2)) * (Camera.ViewportSize.Y / 2)
                end
            end)
            aimlockConnections = {beganConn, aimlockConn}
        else
            isAimlockActive = false
            if aimlockConnections then
                for _, conn in ipairs(aimlockConnections) do
                    conn:Disconnect()
                end
                aimlockConnections = nil
            end
            if aimlockConn then
                aimlockConn:Disconnect()
                aimlockConn = nil
            end
            fovCircle.Visible = false
        end
    end
})

CombatTab:CreateToggle({
    Name = "Infinite Ammo ON/OFF",
    CurrentValue = false,
    Callback = function(state)
        infiniteAmmoEnabled = state
        if infiniteAmmoEnabled and not playerConn then
            updatePlayerMechanics()
        elseif not (speedEnabled or flyEnabled or infiniteAmmoEnabled or infiniteStaminaEnabled) and playerConn then
            playerConn:Disconnect()
            playerConn = nil
            resetStamina() --- POPRAWKA: Reset stamina przy OFF
        end
    end
})

---------------------------------------------------
-- ESP section
---------------------------------------------------
local espEnabled = false
local chamsEnabled = false
local espColor = Color3.fromRGB(0, 255, 0)
local chamsColor = Color3.fromRGB(255, 0, 0)
local espDrawings = {}
local chamsDrawings = {}

local function getPlayerComponents(plr)
    local char = plr.Character
    return char, char and char:FindFirstChild("HumanoidRootPart"), char and char:FindFirstChildOfClass("Humanoid")
end

local function createEsp(plr)
    if plr == LocalPlayer then return end
    local text = Drawing.new("Text")
    text.Size = 14
    text.Center = true
    text.Outline = true
    text.Color = espColor
    text.Visible = false
    espDrawings[plr] = text
end

local function removeEsp(plr)
    if espDrawings[plr] then
        espDrawings[plr]:Remove()
        espDrawings[plr] = nil
    end
end

local function createChams(plr)
    if plr == LocalPlayer then return end
    local highlight = Instance.new("Highlight")
    highlight.FillColor = chamsColor
    highlight.OutlineColor = Color3.fromRGB(255, 255, 255)
    highlight.FillTransparency = 0.5
    highlight.OutlineTransparency = 0
    highlight.Enabled = false
    chamsDrawings[plr] = highlight
end

local function removeChams(plr)
    if chamsDrawings[plr] then
        chamsDrawings[plr]:Remove()
        chamsDrawings[plr] = nil
    end
end

Players.PlayerAdded:Connect(function(plr)
    createEsp(plr)
    createChams(plr)
    updateHitbox(plr)
    updateHeadChams(plr)
end)

Players.PlayerRemoving:Connect(function(plr)
    removeEsp(plr)
    removeChams(plr)
    originalHeadSizes[plr] = nil
    if headChamsDrawings[plr] then
        headChamsDrawings[plr]:Remove()
        headChamsDrawings[plr] = nil
    end
end)

for _, p in ipairs(Players:GetPlayers()) do
    createEsp(p)
    createChams(p)
    updateHitbox(p)
    updateHeadChams(p)
end

RunService.RenderStepped:Connect(function()
    if not (espEnabled or chamsEnabled) then
        for _, d in pairs(espDrawings) do d.Visible = false end
        for _, h in pairs(chamsDrawings) do h.Enabled = false end
        return
    end

    for plr, text in pairs(espDrawings) do
        local char, root, hum = getPlayerComponents(plr)
        if espEnabled and hum and root then
            local pos, vis = Camera:WorldToViewportPoint(root.Position)
            text.Visible = vis
            if vis then
                text.Position = Vector2.new(pos.X, pos.Y - 20)
                text.Text = string.format("%s | HP: %d", plr.Name, hum.Health)
                text.Color = espColor
            end
        else
            text.Visible = false
        end
    end

    for plr, highlight in pairs(chamsDrawings) do
        highlight.Adornee = plr.Character
        highlight.FillColor = chamsColor
        highlight.Enabled = chamsEnabled and plr.Character ~= nil
    end
end)

-- ESP Tab UI
EspTab:CreateToggle({
    Name = "ESP Nick + HP",
    CurrentValue = false,
    Callback = function(state)
        espEnabled = state
    end
})

EspTab:CreateColorPicker({
    Name = "ESP Nick + HP Color",
    Color = espColor,
    Callback = function(color)
        espColor = color
        for _, text in pairs(espDrawings) do
            text.Color = espColor
        end
    end
})

EspTab:CreateToggle({
    Name = "Chams ON/OFF",
    CurrentValue = false,
    Callback = function(state)
        chamsEnabled = state
    end
})

EspTab:CreateColorPicker({
    Name = "Chams Color",
    Color = chamsColor,
    Callback = function(color)
        chamsColor = color
        for _, highlight in pairs(chamsDrawings) do
            highlight.FillColor = chamsColor
        end
    end
})
